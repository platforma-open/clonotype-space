wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
smart := import("@platforma-sdk/workflow-tengo:smart")
ll := import("@platforma-sdk/workflow-tengo:ll")
render := import("@platforma-sdk/workflow-tengo:render")

xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")

slices := import("@platforma-sdk/workflow-tengo:slices")
text := import("text")
umapConv := import(":pf-umap-conv")

pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
umapCalculationTpl := assets.importTemplate(":umap-calculation")

wf.prepare(func(args){
	// We need a table with clonotype id and selected sequence columns

	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
	bundleBuilder.addAnchor("main", args.inputAnchor)

	// Add user-selected sequence features
	for ref in args.sequencesRef {
		bundleBuilder.addSingle(ref)
	}

	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {

	blockId := wf.blockId().getDataAsJson()

	// Input arguments
	columns := args.columns
	datasetSpec := columns.getSpec(args.inputAnchor)
	umap_neighbors := args.umap_neighbors
	umap_min_dist := args.umap_min_dist

	if is_undefined(umap_neighbors) || is_undefined(umap_min_dist) {
		ll.panic("umap_neighbors or umap_min_dist is undefined")
	}

	// Get alphabet from args (all selected sequences must have same alphabet)
	alphabet := args.sequenceType

	// Needed conditional variables
	isSingleCell := datasetSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey"

	// output containers
	outputs := {}

	////////// UMAP //////////
	// Generate input TSV with Clonotype ID and sequences
	umapTable := pframes.tsvFileBuilder()
	umapTable.mem("8GB") // TODO: make this dynamic on input size
	umapTable.setAxisHeader(datasetSpec.axesSpec[1].name, "clonotypeKey")

	// Add all selected sequences with unique headers
	for nr, seqRef in args.sequencesRef {
		seq := columns.getColumn(seqRef)
		// Use sequence number to ensure uniqueness
		umapTable.add(seq, {header: "sequence_" + string(nr)})
	}

	umapTable.mem("16GiB")
	umapTable.cpu(1)
	umapTable = umapTable.build()

	mem := args.mem
	cpu := args.cpu

	// Call UMAP calculation subtemplate
	umapRender := render.create(umapCalculationTpl, {
		umapTable: umapTable,
		umap_neighbors: umap_neighbors,
		umap_min_dist: umap_min_dist,
		alphabet: alphabet,
		mem: mem,
		cpu: cpu
	})

	// Get UMAP file and stdout stream from subtemplate
	umapTsVFile := umapRender.output("umapTsVFile")
	umapOutput := umapRender.output("umapOutput")

	// Import UMAP results to PFrame
	umapPf := xsv.importFile(
		umapTsVFile,
		"tsv",
		umapConv.getColumns(datasetSpec, blockId), 
		{ 
			splitDataAndSpec: true,
			cpu: 1,
			mem: "16GiB" // TODO: make this dynamic on input size
		})

	// Make trace with informative label
	neighborsStr := string(umap_neighbors)
	minDistStr := string(umap_min_dist)

	// Build sequence labels list
	seqLabels := []
	for seqRef in args.sequencesRef {
		seqSpec := columns.getSpec(seqRef)
		seqLabel := seqSpec.annotations["pl7.app/label"]
		if is_undefined(seqLabel) {
			// Fallback to feature name if label not available
			feature := seqSpec.domain["pl7.app/vdj/feature"]
			if !is_undefined(feature) {
				alphabetSuffix := alphabet == "aminoacid" ? " aa" : " nt"
				seqLabel = string(feature) + alphabetSuffix
			} else {
				seqLabel = "sequence"
			}
		}
		seqLabels = append(seqLabels, seqLabel)
	}
	seqLabels = slices.quickSort(seqLabels)
	seqLabelsStr := text.join(seqLabels, "+")

	traceLabel := "UMAP (seq:" + seqLabelsStr + ", neighbors:" + neighborsStr + ", min_dist:" + minDistStr + ")"
	
	// Make trace
	trace := pSpec.makeTrace(datasetSpec,
		{
			type: "milaboratories.clonotype-space",
			importance: 20,
			label: traceLabel
		})

	pf := pframes.pFrameBuilder()
	for k, v in umapPf {
		pf.add(k, trace.inject(v.spec), v.data)
	}
		
	// Build the final PFrame
	pf = pf.build()

	return {
		outputs: {
			umapPf: pframes.exportFrame(pf),
			umapOutput: umapOutput
		},
		exports: {
			umapPf: pf
		}
	}
})
