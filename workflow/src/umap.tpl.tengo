// run annotation and DE analysis
self := import("@platforma-sdk/workflow-tengo:tpl")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
umapConv := import(":pf-umap-conv")

self.validateInputs({
	"__options__,closed": "",
	emptyOrNot: "any",
	umapTable: "any",
	datasetSpec: "any",
	blockId: "string"
})

self.defineOutputs("pf", "inputState")

self.body(func(inputs) {
	pf := {}
	inputState := {}

	if string(inputs.emptyOrNot.getData()) == "empty" {
		// If matrix is not full rank return empty objects
		return {
			pf: pf,
			inputState: {content: "empty"}
		}

	} else {
		// Proceed only if metadata matrix is full rank
		umapClones := exec.builder().
			software(assets.importSoftware("@platforma-open/milaboratories.clonotype-space.umap:main")).
			mem("64GiB").
			cpu(1).
			addFile("sequences.tsv", inputs.umapTable).
			arg("-i").arg("sequences.tsv").
			arg("-u").arg("umap.tsv").
			saveFile("umap.tsv").
			printErrStreamToStdout().
			saveStdoutContent().
			cache(24 * 60 * 60 * 1000).
			run()

		umapPf := xsv.importFile(
			umapClones.getFile("umap.tsv"),
			"tsv",
			umapConv.getColumns(inputs.datasetSpec, inputs.blockId), 
			{ splitDataAndSpec: true, cpu: 1, mem: "64GiB" })

		// Make trace
		trace := pSpec.makeTrace(inputs.datasetSpec,
			{
				type: "milaboratories.clonotype-space",
				importance: 30,
				label: "Clonotype Space"
			})

		pf := pframes.pFrameBuilder()
		for k, v in umapPf {
			pf.add(k, trace.inject(v.spec), v.data)
		}
			
		// Build the final PFrame
		pf = pf.build()

		return {
			pf: pf,
			inputState: {content: "notEmpty"}
		}
	} 
})
